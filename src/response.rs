use bytes::Bytes;
use http_body_util::combinators::BoxBody;
use hyper::{
    header::{self, HeaderValue},
    Response,
};

/// Common type for all responses, since [`Response`] is generic but we don't
/// need so much flexibility at a proxy level. Most of the times the real
/// response is generated by the target server and we just send it back to
/// the client.
pub(crate) type BoxBodyResponse = Response<BoxBody<Bytes, hyper::Error>>;

/// Response sent back to the client at the end of the proxying process. It
/// wraps the response received by the target server and when necessary we can
/// call [`ProxyResponse::into_forwarded`] to obtain the final response.
pub(crate) struct ProxyResponse<T> {
    /// Original response received from a server behind this proxy.
    response: Response<T>,
}

impl<T> ProxyResponse<T> {
    /// Creates a new [`ProxyResponse`], wrapping the original response.
    pub fn new(response: Response<T>) -> Self {
        Self { response }
    }

    /// Consumes this [`ProxyResponse`] and returns the final response that
    /// should be sent to the client.
    pub fn into_forwarded(mut self) -> Response<T> {
        self.response.headers_mut().insert(
            header::SERVER,
            HeaderValue::from_str(rxh_server_header().as_str()).unwrap(),
        );

        self.response
    }
}

/// HTTP response originated on this server, not obtained through a proxy
/// process.
pub(crate) struct LocalResponse;

impl LocalResponse {
    /// Response builder pre-initialized with our header values.
    pub fn builder() -> http::response::Builder {
        Response::builder().header(header::SERVER, rxh_server_header())
    }

    /// Generic `HTTP 404 Not Found` response.
    pub fn not_found() -> BoxBodyResponse {
        Self::builder()
            .status(http::StatusCode::NOT_FOUND)
            .header(header::CONTENT_TYPE, "text/plain")
            .body(body::full("HTTP 404 NOT FOUND"))
            .unwrap()
    }

    pub fn bad_gateway() -> BoxBodyResponse {
        Self::builder()
            .status(http::StatusCode::BAD_GATEWAY)
            .header(header::CONTENT_TYPE, "text/plain")
            .body(body::full("HTTP 502 BAD GATEWAY"))
            .unwrap()
    }
}

/// Let everybody know who is running this server ;)
///
/// ```http
/// HTTP/2 200 OK
/// Server: rxh/0.1.0
/// Content-Type: text/plain; charset=utf-8
/// Content-Length: 11
/// Date: Sat, 07 Jan 2023 01:46:50 GMT
///
/// Hello World
/// ```
///
/// TODO: Allow configuration for this header (no version, custom string, etc).
#[inline]
pub(crate) fn rxh_server_header() -> String {
    format!("rxh/{}", crate::VERSION)
}

pub mod body {
    //! Utilities for creating common response bodies.

    use bytes::Bytes;
    use http_body_util::{combinators::BoxBody, BodyExt, Empty, Full};

    /// Single chunk body.
    pub(crate) fn full<T: Into<Bytes>>(chunk: T) -> BoxBody<Bytes, hyper::Error> {
        Full::new(chunk.into())
            .map_err(|never| match never {})
            .boxed()
    }

    #[allow(dead_code)]
    pub fn empty() -> BoxBody<Bytes, hyper::Error> {
        Empty::<Bytes>::new()
            .map_err(|never| match never {})
            .boxed()
    }
}
