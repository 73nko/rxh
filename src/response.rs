use bytes::Bytes;
use http_body_util::combinators::BoxBody;
use hyper::{
    header::{self, HeaderValue},
    Response,
};

/// Common type for all responses, since [`Response`] is generic but we don't
/// need so much flexibility at a proxy level. Most of the times the real
/// response is generated by the target server and we just send it back to
/// the client.
pub(crate) type BoxBodyResponse = Response<BoxBody<Bytes, hyper::Error>>;

/// Let everybody know who is running this server ;)
///
/// ```http
/// HTTP/2 200 OK
/// Server: rxh/0.1.0
/// Content-Type: text/plain; charset=utf-8
/// Content-Length: 11
/// Date: Sat, 07 Jan 2023 01:46:50 GMT
///
/// Hello World
/// ```
#[inline]
pub(crate) fn rxh_server_header() -> String {
    format!("rxh/{}", crate::VERSION)
}

/// Response builder initialized with our server header value.
fn builder() -> http::response::Builder {
    Response::builder().header(header::SERVER, rxh_server_header())
}

/// Generic `HTTP 404 Not Found` response.
pub(crate) fn not_found() -> BoxBodyResponse {
    builder()
        .status(http::StatusCode::NOT_FOUND)
        .header(header::CONTENT_TYPE, "text/plain")
        .body(body::full("HTTP 404 NOT FOUND"))
        .unwrap()
}

/// Adds RXH metadata to the response. For now, we only change the `Server`
/// header.
pub(crate) fn annotate<T>(mut response: Response<T>) -> Response<T> {
    response.headers_mut().insert(
        header::SERVER,
        HeaderValue::from_str(rxh_server_header().as_str()).unwrap(),
    );

    response
}

mod body {
    //! Utilities for creating common response bodies.

    use bytes::Bytes;
    use http_body_util::{combinators::BoxBody, BodyExt, Full};

    /// Single chunk body.
    pub(crate) fn full<T: Into<Bytes>>(chunk: T) -> BoxBody<Bytes, hyper::Error> {
        Full::new(chunk.into())
            .map_err(|never| match never {})
            .boxed()
    }
}
